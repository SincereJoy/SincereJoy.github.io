---
title: Effective C++
key: 10
author: ZE
tags: C++
---
条款1-23

<!--more-->

## 习惯C++
### 条款1：C++语言联邦
四个*次语言*

|---
| 次语言   | 包含内容 | 高效传参方式
|:-:|:-:|:-:
| C part of C++ | 内置数据类型、array、指针等 |pass-by-value
| Object-Oriented | 类（包括构造和析构函数）、封装、继承、多态、虚函数（动态绑定）等 |pass-by-reference-to-const
| template C++ | 模板 |pass-by-reference-to-const
| STL | 容器、迭代器、算法、函数对象 |pass-by-value
|---

C++的高效编程视情况而变，取决于使用的是C++的哪一部分。举例来说，对于传值和传引用的选择，如果使用的是C++中C语言的成分，传值比传引用高效；对于面向对象编程的部分，传常引用更高效；使用模板的泛型编程也是传常饮用更高效；而对于STL部分，迭代器和函数对象都是基于C指针实现的，所以对于STL迭代器和函数对象而言，传值更高效。[条款20](#条款20) 详细地介绍了传参方式地选择。

### 条款2：用编译替代预处理
尽量用const、enum、inline来代替#define，也就是说用const定义常量，用inline代替宏。

这样做是为了让编译器更好地定位错误。由于#define是在预处理阶段进行的文本替换，编译器只能获取已经替换后的常量的值，而非常量名，当我们使用非自定义的头文件时，需要花费很多时间追踪错误来源。而使用const、enum和inline则可以直接定位到引发错误的常量名。

### 条款3：尽可能地使用const
* 当期望某个值保持不变时，使用const，编译器会在程序尝试修改该值时报错
* const修饰指针：const在\*前表示被指向的值是常量，const在\*后表示指针自身是常量
* const迭代器：const修饰迭代器，表示迭代器是常量，不能自增；const_iterator指向的对象是常量，不能修改指向对象的值
* const成员函数：const成员函数可以操作const变量，很多函数会有一个非const版本和一个const版本（重载），在某些情况下，如果const版本的函数实现了跟非const函数完全相同的功能，只是返回值不同，可以在非const函数中调用const函数，然后通过const_cast完成类型转换，避免大量代码重复。
* 
### 条款4：确保对象被使用前已被初始化
C part of C++不保证会进行默认初始化（array），而non-C part of C++在没有显式初始化时会给对象赋默认值（vector<int>默认元素初始化为0）。

* 对于内置类型，在使用之前手动将它初始化。
* 对于非内置类型的变量，初始化由构造函数完成。在构造函数内部对成员变量进行的赋值操作其实不是初始化，它会先调用默认构造函数给成员变量赋初值，然后再执行新的赋值操作；真正的初始化应该通过成员初始化列表来完成，每个成员变量是对传入实参进行拷贝构造得到的，比先初始化再拷贝赋值高效。

成员变量总是以其声明的顺序初始化，成员初始化列表中的顺序不会影响初始化的顺序，但最好跟变量初始化的顺序保持一致。
{:info}

* 用局部静态变量替代非局部静态变量来解决跨编译单元的初始化顺序问题？

## 构造/析构/赋值运算
### 条款5：了解编译器自动生成/调用的函数
当定义一个空类时，编译器会自动生成哪些函数？
* 默认构造函数
* 析构函数
* 拷贝构造函数
* 赋值运算符

这些函数只有在被调用的时候才会创建，如果我们一直没有用到赋值操作，那么赋值运算符函数就不会被创建。
{:info}

在一些特殊情况下编译器不会自动生成赋值运算函数，比如基类把复制原酸设为了private，派生类就不会自动生成operator=，对于包含const成员或者reference成员的类也不会自动生成。
{:info}

### 条款6：不想使用自动生成的函数需要明确拒绝
拒绝的方式：
1. 只写函数声明，不写函数体（不实现），并设为private
2. 使用“函数声明=delete;”禁用函数，此时不需要设为private

### 条款7：多态基类析构函数是虚函数
如果基类的析构函数不是虚函数，那么当我们使用多态时，用基类指针指向一个派生类对象，然后调用基类的析构函数，此时派生类对象的一些成员不会被销毁，会造成内存泄漏。所以需要把基类的析构函数设为虚函数，这样在通过基类指针销毁派生类对象时，会先调用派生类的析构函数，然后再调用基类的析构函数完成正确的析构。

### 条款8：析构函数不应该抛出异常
抛出异常会使得程序提前退出，导致无法完整执行析构函数，会造成内存泄漏等问题。

### 条款9：不能在构造/析构函数中调用虚函数
如果在构造函数中调用虚函数，构造多态派生类对象时会先调用基类构造函数再调用派生类构造函数，如果基类构造函数中调用了虚函数，实际调用的是派生类中对应的虚函数，但此时派生类对象尚未被初始化，很多成员变量都是未初始化状态，因此会造成严重的错误，所以编译器不会让基类构造函数中的虚函数下降至派生类，会将该对象当成一个基类对象来调用基类中对应的函数，此时虚函数是无法实现多态的。在析构函数中调用虚函数也是类似的情况。

### 条款10：赋值运算符返回\*this指针的引用
这样可以实现连锁赋值 x=y=z=1;

### 条款11：在operator=中处理自我赋值
有三种方式：
1. 在operator=中，先判断是否是自我赋值，如果是，直接返回*\this，如果不是，再删除原值，创建新值的副本，返回\*this。但这样依然存在异常安全性的问题。
   
   ![1](/assets/images/post10-11-1.jpg)
2. 不管自我赋值安全性，直接处理异常安全性（赋值后再删除原值），会自动获得自我赋值安全性
   
   ![1](/assets/images/post10-11-2.jpg)
3. 使用swap()

### 条款12：完整地复制对象
拷贝构造函数应该复制所有的成员变量和所有基类成员

不要用某个拷贝函数实现另一个拷贝函数，应该声明第三个函数供两个拷贝函数共用

## 资源管理
### 条款13：使用对象管理资源
把资源放进对象里，用析构函数确保资源被释放

* 获得资源后立刻放入管理对象内：可以用unique_ptr、shared_ptr管理对象。RAII（Resource Acquisition Is Initialization），获取资源后立即用它初始化管理对象，在构造函数中获取资源，在析构函数中释放资源。
* 管理对象用析构函数释放资源：当超出作用域时，unique_ptr会自动析构管理的对象，并销毁自身。

### 条款14：注意资源管理类的复制行为
复制RAII对象必须复制它所管理的资源。通常RAII对象不允许拷贝（unique_ptr）或者使用引用计数（shared_ptr）。

### 条款15：在资源管理类中提供对原始资源的访问
智能指针的get()方法

### 条款16：成对的new和delete要匹配
new对应delete， new []对应delete []
```cpp
std::string* s1 = new std::string;
std::string* s2 = new std::string[100];
···
delete s1;
delete [] s2;
```
### 条款17：用独立语句将资源放入智能指针
用独立语句将资源放入智能指针，在创建资源和把资源交给智能指针之间不要插入任何其他操作（保证RAII），否则，如果其他操作抛出异常，就可能导致资源泄露。

## 设计与声明
### 条款18：让接口更易用，不易被误用
待补充

### 条款19：像设计类型（type）那样设计类（class)
设计类需要考虑的问题：
* 对象应该如何被创建和销毁？构造/析构函数
* 对象初始化和赋值的差别？构造函数和赋值运算符的行为
* 新类型对象的传值意味着什么？拷贝构造函数
* 合法值有哪些？
* 是否继承其他类？
* 需要哪些类型转换？类型转换函数
* 新类型可以使用哪些操作符和函数？成员函数的设计
* 需要禁用哪些标准函数？
* 成员变量的封装性？
* 一般化程度？定义class还是class template
* 真的需要一个新type吗？是否可以用几个非成员函数或者模板来实现

### 条款20：用传常引用代替传值
传值实际上传入的是实参的副本（通过调用拷贝构造函数获得），当函数返回时对应的副本会被销毁，这会造成很大的计算开销。此外，传值还会引起***对象切割***问题，对于一个参数为基类对象的函数，我们有时会传入一个派生类对象来实现多态，但当通过传值方式传入一个派生类对象时，该函数会调用基类对象的拷贝构造函数，会造成派生类特有的性质消失，只剩下基类的部分。

传常量引用可以解决拷贝和对象切割的问题。传引用实际上传入的是实参的别名，不会调用构造和析构函数，常量引用则保证了实参不被修改。

但对于内置类型以及STL的迭代器和函数对象来说，传值往往比传引用高效。

### 条款21：不要返回指向局部变量的引用
当我们要返回一个在函数内部创建的局部变量时，需要以传值的方式直接返回，不能返回它的引用。

当局部变量是一个栈对象时，它将在函数退出时被自动销毁，因此不能返回指向它的指针或者引用。

当局部变量是在堆上创建时，可以返回指向它的指针，但不能返回它的引用，因为在某些情况下我们无法在外部通过引用delete这个变量。例如重载有理数类的乘法运算符，然后进行连乘运算，我们最终只能得到一个引用，但确有两个需要销毁的变量：
```cpp
const Rational& operator*(const Rational& lhs, const Rational& rhs){
    Rational* result = new Rational(lhs.n*rhs.n, lhs.d*rhs.d);
    return *result;
}
···
Rational w,x,y,z;
w = x*y*z;
```
### 条款22：将成员变量声明为private
将成员变量声明为private，类的封装性会更好，成员变量的封装性跟它的内容改变时可能造成的代码破坏量成反比，如果我们删除了一个public成员变量，所有使用了这个变量的代码都会被破坏，所以我们最好把成员变量声明为private封装起来，不让外部直接访问它。

另外，我们能够通过成员函数更精确地控制每个成员变量，因为外部只能通过成员函数访问成员变量，所以我们可以用成员函数来限制对每个变量可以进行哪些操作，而哪些操作是不被允许的。

### 条款23：尽可能用非成员、非友元函数替换成员函数
非成员、非友元函数比成员函数封装性更强，因为成员函数是能够访问类的private成员变量的，而非成员和非友元函数不会。通常会把非成员函数放在类的同一个命名空间里。