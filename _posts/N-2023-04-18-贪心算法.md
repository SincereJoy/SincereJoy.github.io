# 贪心算法
贪心算法是动态规划的一种特殊情况，需要满足”局部最优选择会导向全局最优解“的条件。
这里主要总结了区间相关的问题（例如合并区间，区间去重，安排会议室等）。

对于区间问题，一般都要先对这些区间进行排序，然后根据各个区间左右边界之间的关系求解。

## 重叠区间
重叠区间相关的题目一般会给出一个区间列表（例如，[[1,2],[2,3],[3,4],[1,3]])，要求删除被其它区间包含的区间，或者找出不重叠的区间。以下是三个比较有代表性的重叠区间题目。

### [Leetcode 435. 无重叠区间 Mid](https://leetcode.cn/problems/non-overlapping-intervals/)
> 给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。
> 
> 示例：
> 输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
> 
> 输出: 1
> 
> 解释: 移除 [1,3] 后，剩下的区间没有重叠。
> 
**思路**：
1. 将区间列表按照右边界(endi)从小到大排序；
2. 取最小的右边界（curEnd），依次检查后面的区间是否跟它重叠（check if starti < curEnd），若重叠，则计数count++；
3. 当遇到第一个不重叠的区间时，更新curEnd，重复第二步，直到遍历完所有区间。

**代码**
```cpp

```

### [Leetcode 452. 引爆气球 Mid](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)
>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。
>
>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。
>
>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。

这个题目本质上跟[无重复区间](https://leetcode.cn/problems/non-overlapping-intervals/)一样，只不过上个题求解的是把当前列表变成无重复区间列表需要删除的区间数，而打气球是求无重复区间列表包含的区间数。

**代码**
```cpp

```

### [Leetcode 1288. 删除被覆盖区间 Mid](https://leetcode.cn/problems/remove-covered-intervals/)
> 给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。
>
>只有当 c <= a 且 b <= d 时，我们才认为区间 [a,b) 被区间 [c,d) 覆盖。
>
>在完成所有删除操作后，请你返回列表中剩余区间的数目。

注意覆盖区间与重叠区间的判定方式不同，覆盖区间是指start1 <= start2 且 end2 <= end1，而重叠区间只需要判定start2 < end1。

**思路**
1. 先根据左边界升序排序，左边界相等的区间按照右边界降序排序；
2. 以第一个区间为基准，遍历区间列表，遇到左边界相等的区间直接跳过（肯定覆盖），遇到左边界不相等的，判断右边界是否满足包含条件，满足则继续，不满足则计数+1，将当前区间设为新的基准，继续遍历。

**代码**
```cpp

```
## 合并区间
合并区间问题跟重叠区间的思路差不多，不过重叠区间只要求返回区间的个数，而合并区间问题会要求返回处理后的区间列表。
### [Leetcode 56. 合并区间 Mid](https://leetcode.cn/problems/merge-intervals/)
>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

**思路**：
跟无重复区间问题的思路一样，为了合并重叠区间，在遍历过程中需要记录重叠区间的最大右边界，作为合并后区间的右边界。

1. 按照右边界升序排序；
2. 以第一个区间为基准，遍历列表，检查区间是否重叠（starti <= curEnd，注意这里取等号，因为首尾相接的区间也可以合并 )，并记录最大右边界；
3. 遇到第一个不重叠的区间时，用当前基准的左边界和记录的最大右边界组成合并区间加入到结果列表里，然后将当前区间设为新的基准，继续遍历。

**代码**
```cpp

```
### [Leetcode 986.区间列表的交集 Hard](https://leetcode.cn/problems/interval-list-intersections/)
>给定两个由一些**闭区间**组成的列表，firstList 和 secondList，其中 firstList[i] = [starti, endi] 而 secondList[j] = [startj, endj] 。每个区间列表都是成对**不相交**的，并且**已经排序**。
>
>返回这两个区间列表的交集 。
>
>形式上，闭区间 [a, b]（其中 a <= b）表示实数 x 的集合，而 a <= x <= b 。
>
>两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。

该问题是[合并区间](https://leetcode.cn/problems/merge-intervals/)的扩展，需要合并两个区间列表。

**思路：**
大体思路跟合并单个区间列表一样，需要用**双指针**处理双列表。题目给出的列表已经排序，所以不需要再进行排序操作。
1. 两个指针p1,p2分别指向两个列表的开头，对指针指向的区间进行合并，左边界取二者之中较大的，右边界取二者之中较小的，组成新区间加入到结果列表中；
2. 判断双指针的移动：对于刚才合并的两个区间，如果secondList的右边界较大，说明这个区间可能会跟firstList中的下一个区间继续相交，所以p2不变，p1后移；
3. 重复上述步骤，直到遍历完其中一个列表。

**代码**
```cpp

```
## 会议室问题
扫描线解法

## 跳跃游戏

